std::function
=============

``std::function`` 的实例可以对任何可以调用的目标实体进行存储、复制、和调用操作，这些目标实体包括普通函数、Lambda表达式、函数指针、以及其它函数对象等。

通常 ``std::function`` 是一个函数对象类，它包装其它任意的函数对象，被包装的函数对象具有类型为T1, …,TN的N个参数，并且返回一个可转换到R类型的值。

.. code-block:: cpp

    #include <functional>
    #include <iostream>
    using namespace std;

    std::function< int(int)> Functional;

    // 普通函数
    int TestFunc(int a)
    {
        return a;
    }

    // Lambda表达式
    auto lambda = [](int a)->int{ return a; };

    // 仿函数(functor)
    class Functor
    {
    public:
        int operator()(int a)
        {
            return a;
        }
    };

    // 1.类成员函数
    // 2.类静态函数
    class TestClass
    {
    public:
        int ClassMember(int a) { return a; }
        static int StaticMember(int a) { return a; }
    };

    int main()
    {
        // 普通函数
        Functional = TestFunc;
        int result = Functional(10);
        cout << "普通函数："<< result << endl;

        // Lambda表达式
        Functional = lambda;
        result = Functional(20);
        cout << "Lambda表达式："<< result << endl;

        // 仿函数
        Functor testFunctor;
        Functional = testFunctor;
        result = Functional(30);
        cout << "仿函数："<< result << endl;

        // 类成员函数
        TestClass testObj;
        Functional = std::bind(&TestClass::ClassMember, testObj, std::placeholders::_1);
        result = Functional(40);
        cout << "类成员函数："<< result << endl;

        // 类静态函数
        Functional = TestClass::StaticMember;
        result = Functional(50);
        cout << "类静态函数："<< result << endl;

        return 0;
    }

.. warning::

    关于可调用实体转换为std::function对象需要遵守以下两条原则： 
    1. 转换后的 ``std::function`` 对象的参数能转换为可调用实体的参数。
    2. 可调用实体的返回值能转换为 ``std::function`` 对象的返回值。

Lambda表达式
===========

“Lambda 表达式”(lambda expression)是指匿名函数，基本语法如下：

**[capture list] (parameter list) ->return type { function body }**

- [] // 沒有定义任何变量。使用未定义变量会导致错误。 
- [x, &y] // x 以传值的方式传入，y 以参考方式传入。 
- [&] // 任何被使用到的外部变量皆隐式地以參考方式加以引用。 
- [=] // 任何被使用到的外部变量皆隐式地以传值方式加以引用。 
- [&, x] // x 显式地以传值方式加以引用。其余变量以参考方式加以引用。 
- [=, &z] // z 显式地以参考方式加以引用。其余变量以传值方式加以引用。

.. code-block:: cpp

    class CTest 
    { 
    public:  
    CTest() : m_nData(20) { NULL; }  
    void TestLambda()  
    {   
        vector<int> vctTemp;   
        vctTemp.push_back(1);   
        vctTemp.push_back(2);    

    // 无函数对象参数，输出：1 2   
    {    
        for_each(vctTemp.begin(), vctTemp.end(), [](int v){ cout << v << endl; });   
    }   

    // 以值方式传递作用域内所有可见的局部变量（包括this），输出：11 12   
    {    
        int a = 10;    
        for_each(vctTemp.begin(), vctTemp.end(), [=](int v){ cout << v+a << endl; });   
    }    

    // 以引用方式传递作用域内所有可见的局部变量（包括this），输出：11 13 12   
    {    
        int a = 10;   
        for_each(vctTemp.begin(), vctTemp.end(), [&](int v)mutable{ cout << v+a << endl; a++; });    
        cout << a << endl;   
    }    

    // 以值方式传递局部变量a，输出：11 13 10   
    {    
        int a = 10;    
        for_each(vctTemp.begin(), vctTemp.end(), [a](int v)mutable{ cout << v+a << endl; a++; });    
        cout << a << endl;   
    }    

    // 以引用方式传递局部变量a，输出：11 13 12   
    {    
        int a = 10;    
        for_each(vctTemp.begin(), vctTemp.end(), [&a](int v){ cout << v+a << endl; a++; });    
        cout << a << endl;  
    }    

    // 传递this，输出：21 22 
    {  
        for_each(vctTemp.begin(), vctTemp.end(), [this](int v){ cout << v+m_nData << endl; });   
    }    

    // 除b按引用传递外，其他均按值传递，输出：11 12 17   
    {    
        int a = 10;    
        int b = 15;    
        for_each(vctTemp.begin(), vctTemp.end(), [=, &b](int v){ cout << v+a << endl; b++; });    
        cout << b << endl;   
    }     
    // 操作符重载函数参数按引用传递，输出：2 3   
    {    
        for_each(vctTemp.begin(), vctTemp.end(), [](int &v){ v++; });    
        for_each(vctTemp.begin(), vctTemp.end(), [](int v){ cout << v << endl; });   
    }    
    // 空的Lambda表达式   
    {    
        [](){}();    []{}();   
    }  
    }  
    private:  int m_nData; 
    };

override和final关键字
====================

C++11之前，一直没有继承控制关键字。禁用一个类的进一步衍生是可能的但也很棘手。为避免用户在派生类中重载一个虚函数，你不得不向后考虑。

C++11添加了两个继承控制关键字：override和final。override确保在派生类中声明的重载函数跟基类的虚函数有相同的签名。final阻止类的进一步派生和虚函数的进一步重载。

initializer_list
================

C++11允许构造函数和其他函数把初始化列表当做参数，举例如下：

.. code-block:: cpp

    class CompareClass 
    {
    CompareClass (int,int);
    CompareClass (initializer_list<int>);
    };

    int main（）
    {
        myclass foo {10,20};  // calls initializer_list ctor
        myclass bar (10,20);  // calls first ctor 
    }

default and delete specifiers
============================
- default

创建类时，如果自己提供了任何形式的构造函数，那么编译器将不会产生默认构造函数。
``default`` 关键字则告诉编译器产生一个默认构造函数，如：

.. code-block:: cpp

    class A
    {
    public:
        A(int a){}
        A() = default;
    };

- delete

禁用被 ``delete`` 修饰的函数签名。

.. code-block::

    class A
    {
    public:
        A(int a){};
        A(double) = delete;         // conversion disabled
        A& operator=(const A&) = delete;  // assignment operator disabled
    };
    int main{
        A a(10);     // OK
        A b(3.14);   // Error: conversion from double to int disabled
        a = b;       // Error: assignment operator disabled
    }

右值引用和移动语义
=================

左值VS右值
----------

C++中所有的值都必然属于左值、右值二者之一。
左值是指表达式结束后依然存在的持久化对象，右值是指表达式结束时就不再存在的临时对象。
所有的具名变量或者对象都是左值，而右值不具名。
很难得到左值和右值的真正定义，但是有一个可以区分左值和右值的便捷方法：看能不能对表达式取地址，如果能，则为左值，否则为右值。

左值引用VS右值引用
-----------------

在C++98中，右值不能被引用。

.. code-block:: cpp

    int a = 10; int& refA = a; // refA是a的别名， 修改refA就是修改a, a是左值，refA是左值引用
    int& b = 1; //编译错误! 1是右值，不能够使用左值引用

C++11中引入了右值引用(rvalue reference)的概念，使用的符号是 ``&&``。

.. code-block:: cpp

    int&& a = 1;  // 实质上就是将不具名(匿名)变量取了个别名
    int b = 1;
    int&& c = b;  // 编译错误！不能将一个左值复制给一个右值引用
    int getTemp()
    {
        return int(0);
    }
    int&& a = getTemp();  // getTemp()的返回值是右值（临时变量）

.. note::

    这里a的类型是右值引用类型(int&&)，但是如果从左值和右值的角度区分它，它实际上是个左值。因为可以对它取地址，而且它还有名字，是一个已经命名的右值。

所以，左值引用只能绑定左值，右值引用只能绑定右值，如果绑定的不对，编译就会失败。

但是，常量左值引用却是个例外，它可以绑定非常量左值、常量左值、右值，而且在绑定右值的时候，常量左值引用还可以像右值引用一样将右值的生命期延长。

.. code-block::

    const int& a = 1;  // 常量左值引用绑定右值，不会报错
 
    int getTemp()
    {
        return int(0);
    }
    const int& a = getTemp();  // 不会报错

移动语义
--------

移动语义狭义上是指移动构造函数和移动赋值函数。

基于“右值是指表达式结束时就不再存在的临时对象”这个特点，可以创建移动构造函数来充分利用该右值（临时变量）的内容，以达到优化性能的目标。

.. code-block:: cpp

    #include <iostream>
    #include <cstring>
    #include <vector>
    using namespace std;
    
    class MyString
    {
    public:
        static size_t CCtor;  // 统计调用拷贝构造函数的次数
        static size_t MCtor;  // 统计调用移动构造函数的次数
    public:
        // 构造函数
        MyString(const char* cstr=0){
            if (cstr) {
                m_data = new char[strlen(cstr)+1];
                strcpy(m_data, cstr);
            }
            else {
                m_data = new char[1];
                *m_data = '\0';
            }
        }
    
        // 拷贝构造函数
        MyString(const MyString& str) {
            CCtor++;
            m_data = new char[ strlen(str.m_data) + 1 ];
            strcpy(m_data, str.m_data);
        }

        // 移动构造函数
        MyString(MyString&& str) noexcept
            :m_data(str.m_data) {  // 直接把参数的资源抢过来，避免复制。
            MCtor++;
            str.m_data = nullptr;  // 不再指向之前的资源
        }

        ~MyString() {
            delete[] m_data;
        }

        char* get_c_str() const { return m_data; }
    private:
        char* m_data;
    };

    size_t MyString::CCtor = 0;
    size_t MyString::MCtor = 0;
    
    int main()
    {
        vector<MyString> vecStr;
        vecStr.reserve(1000);  // 先分配好1000个空间
        for(int i=0;i<1000;i++){
            MyString tmp("hello");
            vecStr.push_back(tmp);  // 调用的是拷贝构造函数
        }
        cout << "CCtor = " << MyString::CCtor << endl;
        cout << "MCtor = " << MyString::MCtor << endl;
        cout << endl;
    
        MyString::CCtor = 0;
        MyString::MCtor = 0;
        vector<MyString> vecStr2;
        vecStr2.reserve(1000);  // 先分配好1000个空间
        for(int i=0;i<1000;i++){
            vecStr2.push_back(MyString("hello");  // 传入右值，调用移动构造函数
        }
        cout << "CCtor = " << MyString::CCtor << endl;
        cout << "MCtor = " << MyString::MCtor << endl;
    }

    /* 运行结果
    CCtor = 1000
    MCtor = 0
    
    CCtor = 0
    MCtor = 1000
    */

从上面的例子可以看到，C++程序在执行时可以分辨参数是左值还是右值，再决定调用哪个构造函数。
而移动构造函数接受一个右值作为参数，可以直接把参数的资源给抢过来，从而避免复制，毕竟临时对象的资源不好好利用也是浪费。

同理，也可以重载 ``=`` 操作符并接受右值引用类型，来构造移动赋值函数。

std::move
-------

基于上面的例子，
对于一个左值，肯定是调用拷贝构造函数，但是有些左值是局部变量，生命周期也很短，能否也调用移动构造函数？

C++11为了解决这个问题，提供了 ``std::move()`` 方法来将左值转换为右值，从而方便应用移动语义。
它其实就是告诉编译器，虽然我是一个左值，但是不要对我用拷贝构造函数，而是用移动构造函数。

.. code-block:: cpp

    for(int i=0;i<1000;i++){
        MyString tmp("hello");
        vecStr2.push_back(std::move(tmp)); // 移动语义，调用的是移动构造函数
    }

完美转发
========

通用引用（universal references）
------------------------------

当右值引用和模板结合的时候， ``T&&`` 并不一定表示右值引用，它可能是个左值引用又可能是个右值引用。例如

.. code-block:: cpp

    template<typename T>
    void f( T&& param){
        
    }
    f(10);  // 10是右值
    int x = 10;
    f(x);  // x是左值

.. note::

    在一些复杂情况下，需要通过“引用折叠”规则来判断到底是左值引用还是右值引用。

    - 所有的右值引用叠加到右值引用上仍然使一个右值引用。

    - 所有的其他引用类型之间的叠加都将变成左值引用。

.. warning:: 

    通用引用仅仅发生在 ``T&&`` 下，任何一点附加条件都会使之失效，比如：

.. code-block:: cpp

    template<typename T>
    void f(const T&& param);  // 右值引用

    template<typename T>
    void f(std::vector<T>&& param);  // 右值引用

总结通用引用：传递左值进去，就是左值引用；传递右值进去，就是右值引用。如它的名字，这种类型确实很"通用"，下面要讲的完美转发，就利用了这个特性。

完美转发
--------

所谓转发，就是通过一个函数将参数继续转交给另一个函数进行处理，原参数可能是左值引用类型，可能是右值引用，如果还能继续保持参数的原有特征，那么它就是完美的。

.. code-block:: cpp

    void process(int& i){
        cout << "process(int&):" << i << endl;
    }
    void process(int&& i){
        cout << "process(int&&):" << i << endl;
    }
    
    void myforward(int&& i){
        cout << "myforward(int&&):" << i << endl;
        process(i);
    }
    
    int main()
    {
        int a = 0;
        process(a);  // a是左值 process(int&):0
        process(1);  // 1是右值 process(int&&):1
        process(move(a));  // 移动语义，将a由左值改为右值 process(int&&):0
        myforward(2);
        /*
        右值在函数内部转交给process，然而 ``i `` 虽然是右值引用类型，但其本身是个左值
        process(int&):2
        */
        myforward(move(a));  // 同上，在转发的时候右值变成了左值  process(int&):0
    }

上面的例子就是不完美转发，没有保持调用时期望的右值特性。解决这个问题需要用到c++11提供的 ``std::forward()`` 模板函数：

.. code-block:: cpp

    void myforward(int&& i){
        cout << "myforward(int&&):" << i << endl;
        process(std::forward<int>(i));
    }

    myforward(2);  // process(int&&):2

经过上面的修改可以转发右值，但是由于 ``myforward`` 函数本身不接受左值，这个转发仍然不完美。
要实现真正的完美转发，还需要用到前面提到的通用引用。

.. code-block:: cpp

    #include <iostream>
    #include <cstring>
    #include <vector>
    using namespace std;
    
    void RunCode(int &&m) {
        cout << "rvalue ref" << endl;
    }
    void RunCode(int &m) {
        cout << "lvalue ref" << endl;
    }
    void RunCode(const int &&m) {
        cout << "const rvalue ref" << endl;
    }
    void RunCode(const int &m) {
        cout << "const lvalue ref" << endl;
    }
    
    template<typename T>
    void perfectForward(T && t) {
        RunCode(forward<T> (t));
    }
    
    int main()
    {
        int a = 0;
        int b = 0;
        const int c = 0;
        const int d = 0;
    
        perfectForward(a); // lvalue ref
        perfectForward(move(b)); // rvalue ref
        perfectForward(c); // const lvalue ref
        perfectForward(move(d)); // const rvalue ref
    }

总结
----

1. 有两种值类型，左值和右值。
2. 有三种引用类型，左值引用、右值引用和通用引用。左值引用只能绑定左值，右值引用只能绑定右值，通用引用由初始化时绑定的值的类型确定。
3. 左值和右值是独立于他们的类型的，右值引用类型可能是左值可能是右值。
4. 引用折叠规则：所有的右值引用叠加到右值引用上仍然是一个右值引用；其他引用折叠都为左值引用。
5. 移动语义可以减少无谓的内存拷贝，要想实现移动语义，需要实现移动构造函数和移动赋值函数。
6. ``std::move()`` 将一个左值转换成一个右值，强制使用移动拷贝和赋值函数，这个函数本身并没有对这个左值什么特殊操作。
7. ``std::forward()`` 和通用引用共同实现完美转发。